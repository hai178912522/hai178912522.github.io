<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Hexo | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="最近在网上看到一篇关于Single-cell best practices的教程，这篇教程，基本上全程使用python对单细胞数据进行分析，我会在发布之前对所有代码进行运行和测试，并对代码进行详细的注释，以帮助我更好的学习。但是，由于我的知识和经验有限，如果在翻译或解释过程中出现任何错误，请您不吝赐教，我会非常感激。如果您需要阅读原文，请在微信公众号上回复“单细胞”，我们会立即为您发送原文链接。">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2023/04/14/6.%20Quality%20Control/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="最近在网上看到一篇关于Single-cell best practices的教程，这篇教程，基本上全程使用python对单细胞数据进行分析，我会在发布之前对所有代码进行运行和测试，并对代码进行详细的注释，以帮助我更好的学习。但是，由于我的知识和经验有限，如果在翻译或解释过程中出现任何错误，请您不吝赐教，我会非常感激。如果您需要阅读原文，请在微信公众号上回复“单细胞”，我们会立即为您发送原文链接。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-04-14T15:43:20.453Z">
<meta property="article:modified_time" content="2023-04-14T15:43:27.272Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/04/14/6.%20Quality%20Control/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Hexo',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-14 23:43:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Hexo"><span class="site-name">Hexo</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">No title</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-04-14T15:43:20.453Z" title="Created 2023-04-14 23:43:20">2023-04-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-04-14T15:43:27.272Z" title="Updated 2023-04-14 23:43:27">2023-04-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>最近在网上看到一篇关于Single-cell best practices的教程，这篇教程，基本上全程使用python对单细胞数据进行分析，<strong>我会在发布之前对所有代码进行运行和测试，并对代码进行详细的注释</strong>，以帮助我更好的学习。但是，由于我的知识和经验有限，如果在翻译或解释过程中出现任何错误，请您不吝赐教，我会非常感激。<br><strong>如果您需要阅读原文</strong>，请在微信公众号上回复“单细胞”，我们会立即为您发送原文链接。</p>
</blockquote>
<h1 id="质量控制"><a href="#质量控制" class="headerlink" title="质量控制"></a>质量控制</h1><h2 id="6-1-索引"><a href="#6-1-索引" class="headerlink" title="6.1 索引"></a>6.1 索引</h2><p>单细胞RNA测序数据具有两个重要属性，需要在进行分析时牢记。首先，scRNA-seq数据存在大量的缺失值，这意味着数据中由于限制性mRNA而存在过多的零。其次，纠正数据并进行质量控制的潜力可能会受到限制，因为数据可能会与生物学相混淆。因此，选择适合基础数据的预处理方法而不是过度纠正或删除生物效应是至关重要的。<br>单细胞RNA测序数据分析工具的集合正在快速发展，这归因于新的测序技术以及捕获细胞、测量基因和鉴定细胞群体的数量不断增加[Zappia和Theis，2021]。其中许多工具专门用于预处理，旨在解决以下分析步骤：Doublet detection、质量控制、标准化、特征选择和降维。本章介绍的工具对下游分析和数据解释有很大影响。例如，在质量控制过程中过滤掉过多的细胞，可能会失去稀有的细胞亚群并错过有趣的细胞生物学信息。而如果您太宽松，可能会在预处理流程中未排除质量差的细胞，从而难以注释您的细胞。因此，选择能够提供最佳实践并且已被证明在下游任务方面优于其他工具的工具非常重要。在许多情况下，您仍然需要重新评估预处理分析并更改，例如，过滤策略。<br>这篇笔记的起点是单细胞数据，该数据已根据原始处理章节中的描述进行处理。数据已经对齐以获得分子计数矩阵，也称为计数矩阵或读取矩阵。计数矩阵和读取矩阵的区别取决于单细胞库构建协议是否包括唯一分子标识符（UMI）。读取矩阵和计数矩阵的维度为barcode数乘以转录本数。需要注意的是，在这里使用术语“barcode”而不是“细胞”，因为barcode可能会错误地标记多个细胞（doublet标记）或未标记任何细胞（空滴）。我们将在“Doublet detection”部分进行更详细的说明。</p>
<h2 id="6-2-环境设置和数据"><a href="#6-2-环境设置和数据" class="headerlink" title="6.2 环境设置和数据"></a>6.2 环境设置和数据</h2><p>我们使用NeurIPS 2021会议上为单细胞数据整合挑战生成的10x Multiome数据集[Luecken等，2021]。该数据集捕获了来自12位健康人类供体的骨髓单核细胞的单细胞多组学数据，测量了四个不同的位置，以获得嵌套的批次效应。在本教程中，我们将使用前述数据集的一个批次，即第8位供体的第4个样本，展示scRNA-seq数据预处理的最佳实践。<br>尽管单细胞计数矩阵预处理通常是一个相当线性的过程，其中各种质量控制和预处理步骤按照明确的顺序进行，但这里介绍的特定步骤有时需要我们跳到我们将在后面的子章节中介绍的步骤。例如，我们利用聚类进行环境RNA校正，但只会在稍后介绍聚类。<br>作为第一步，我们首先使用托管在figshare上的scanpy加载数据集。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import scanpy as sc</span><br><span class="line">import seaborn as sns</span><br><span class="line">from scipy.stats import median_abs_deviation # 导入中位数绝对偏差函数。</span><br><span class="line"></span><br><span class="line">sc.settings.verbosity = 0 # 将scanpy包中的参数verbosity的值设为0，表示在后续代码执行过程中，不显示冗长的信息。</span><br><span class="line">sc.settings.set_figure_params(</span><br><span class="line">    dpi=80,</span><br><span class="line">    facecolor=&quot;white&quot;,</span><br><span class="line">    frameon=False,</span><br><span class="line">)  # 设置scanpy包中绘图的一些参数，包括图像分辨率（dpi）、背景颜色（facecolor）和是否显示图像边框（frameon）等。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adata = sc.read_10x_h5(</span><br><span class="line">    filename=&quot;filtered_feature_bc_matrix.h5&quot;,</span><br><span class="line">    backup_url=&quot;https://figshare.com/ndownloader/files/39546196&quot;,</span><br><span class="line">)</span><br><span class="line">adata</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果数据下载不下来，可以在微信公众号进行留言。<code>filtered_feature_bc_matrix.h5</code>，我将发送阿里云网盘链接给您下载。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Variable names are not unique. To make them unique, call `.var_names_make_unique`.</span><br><span class="line">Variable names are not unique. To make them unique, call `.var_names_make_unique`.</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AnnData object with n_obs × n_vars = 16934 × 36601</span><br><span class="line">    var: &#x27;gene_ids&#x27;, &#x27;feature_types&#x27;, &#x27;genome&#x27;</span><br></pre></td></tr></table></figure>
<p>在读取数据后，scanpy 显示警告，称并非所有变量名称都是唯一的。这表明某些变量（即基因）出现了多次，可能会导致下游分析任务中的错误或意外行为。我们执行建议的函数 <code>var_names_make_unique()</code>，通过在每个重复的索引元素后附加数字字符串 ‘1’、’2’ 等来使变量名称唯一。</p>
<blockquote>
<p>思考：对于分析基因表达数据，变量名的唯一性是非常重要的。如果变量名不唯一，可能会导致下游分析任务中的错误或不准确的结果。因此，我们需要采取措施来确保变量名的唯一性。在这种情况下，执行 var_names_make_unique() 函数是一种简单有效的方法，它会通过在变量名后附加数字字符串来确保每个变量名都是唯一的。这种方法可以避免不必要的错误和混淆，并提高数据分析的准确性和可靠性。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adata.var_names_make_unique()</span><br><span class="line">adata</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AnnData object with n_obs × n_vars = 16934 × 36601</span><br><span class="line">    var: &#x27;gene_ids&#x27;, &#x27;feature_types&#x27;, &#x27;genome&#x27;</span><br></pre></td></tr></table></figure>
<p>数据集的形状为 n_obs 16,934 x n_vars 36,601。这转化为barcode x 转录本数量。我们还会在 .var 中检查有关基因 ID（Ensembl ID）、特征类型和基因组的其他信息。<br>大多数后续分析任务假设数据集中的每个观测值都代表来自一个完整单个细胞的测量。在某些情况下，这种假设可能会被低质量细胞、无细胞RNA的污染或双细胞的存在所违反。本教程将指导您如何纠正和消除这些不正常行为，并获得高质量的数据集。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/16356584/1681402080697-0ad78714-2759-45b1-bf22-a7fd8947c362.png#averageHue=%23f9f9f9&clientId=u544cf9e1-ee1c-4&from=paste&height=497&id=ub49b2744&name=image.png&originHeight=497&originWidth=1011&originalType=binary&ratio=1&rotation=0&showTitle=true&size=188185&status=done&style=none&taskId=uc6ca39f0-2c23-4ad2-abd4-898ec33b568&title=%E5%9B%BE6.1%20%E5%8D%95%E7%BB%86%E8%83%9ERNA%E6%B5%8B%E5%BA%8F%E6%95%B0%E6%8D%AE%E9%9B%86%E5%8F%AF%E8%83%BD%E5%8C%85%E5%90%AB%E4%BD%8E%E8%B4%A8%E9%87%8F%E7%BB%86%E8%83%9E%E3%80%81%E6%97%A0%E7%BB%86%E8%83%9ERNA%E5%92%8C%E5%8F%8C%E9%87%8D%E7%BB%86%E8%83%9E%E3%80%82%E8%B4%A8%E9%87%8F%E6%8E%A7%E5%88%B6%E6%97%A8%E5%9C%A8%E5%8E%BB%E9%99%A4%E5%92%8C%E7%BA%A0%E6%AD%A3%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%8C%E4%BB%A5%E8%8E%B7%E5%BE%97%E4%B8%80%E4%B8%AA%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86%EF%BC%8C%E5%85%B6%E4%B8%AD%E6%AF%8F%E4%B8%AA%E8%A7%82%E5%AF%9F%E5%80%BC%E9%83%BD%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E5%8D%95%E4%B8%AA%E7%BB%86%E8%83%9E%E3%80%82&width=1011" alt="image.png" title="图6.1 单细胞RNA测序数据集可能包含低质量细胞、无细胞RNA和双重细胞。质量控制旨在去除和纠正这些问题，以获得一个高质量的数据集，其中每个观察值都是一个完整的单个细胞。"></p>
<h2 id="6-3-过滤低质量的reads"><a href="#6-3-过滤低质量的reads" class="headerlink" title="6.3. 过滤低质量的reads"></a>6.3. 过滤低质量的reads</h2><p>质量控制的第一步是从数据集中移除低质量的reads。当一个细胞检测到的基因数较少，计数深度较低，线粒体计数的比例较高时，它可能具有破裂的细胞膜，这可能表明细胞正在死亡。由于这些细胞通常不是我们分析的主要目标，可能会误导我们的下游分析，因此我们在质量控制期间将它们移除。为了识别它们，我们定义了细胞质量控制（QC）阈值。细胞QC通常在以下三个QC协变量上执行：</p>
<ol>
<li>每个barcode的计数数量（计数深度）</li>
<li>每个barcode的基因数量</li>
<li>每个barcode中线粒体基因计数的比例</li>
</ol>
<p>在细胞QC中，这些协变量通过阈值筛选进行过滤，因为它们可能对应于死亡细胞。如前所述，它们可能反映了膜破裂的细胞，其胞质mRNA已泄漏出来，因此只有线粒体中的mRNA仍然存在。这些细胞可能显示低计数深度，检测到的基因少，线粒体读数比例高。然而，必须考虑三个QC协变量的联合作用，否则可能会导致细胞信号的错误解释。例如，具有相对较高线粒体计数比例的细胞可能参与呼吸过程，不应被过滤掉。而低计数或高计数的细胞可能对应于休眠细胞群体或体积较大的细胞。因此，最好在单个协变量上进行阈值决策时考虑多个协变量。通常建议排除较少的细胞，并尽可能允许，以避免过滤掉可行的细胞群体或小的亚群体。<br>只对少量或小型数据集进行QC通常以手动方式进行，方法是查看不同QC协变量的分布，并识别之后将被过滤的异常值。然而，随着数据集规模的增长，这项任务变得越来越耗时，因此考虑通过MAD（中位数绝对偏差）进行自动阈值可能是值得的。MAD由以下公式给出：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/16356584/1681402404475-aeb0967c-7288-4806-a425-db3d7c5a9bf3.png#averageHue=%23f3efeb&clientId=u544cf9e1-ee1c-4&from=paste&height=26&id=ub3e09207&name=image.png&originHeight=26&originWidth=294&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4630&status=done&style=none&taskId=u7fc21e12-1de6-4e98-bdec-8001d89f653&title=&width=294" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/16356584/1681402459425-daa3fe8a-1e78-4646-815f-c2a82b215e55.png#averageHue=%23f1eeea&clientId=u544cf9e1-ee1c-4&from=paste&height=25&id=u148d865f&name=image.png&originHeight=25&originWidth=23&originalType=binary&ratio=1&rotation=0&showTitle=false&size=605&status=done&style=none&taskId=uc92cdfae-c767-4108-8965-a539d77518f&title=&width=23" alt="image.png">作为观测的各自QC指标，并描述了该指标变异性的强健统计量。与[Germain et al.，2020]类似，如果细胞相差5个MAD，则将其标记为异常值，这是一种相对宽松的过滤策略。我们想强调，在细胞注释后重新评估过滤可能是合理的。<br>在质控中，第一步是计算QC协变量或度量。我们使用scanpy函数sc.pp.calculate_qc_metrics进行计算，该函数还可以计算特定基因群体的计数比例。因此，我们定义了线粒体、核糖体和血红蛋白基因。需要注意的是，线粒体计数根据数据集中所考虑的物种不同，要么带有前缀“mt-”，要么带有前缀“MT-”。如前所述，本笔记本中使用的数据集是人类骨髓，因此线粒体计数带有前缀“MT-”。对于鼠类数据集，前缀通常为小写，即“mt-”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># mitochondrial genes</span><br><span class="line">adata.var[&quot;mt&quot;] = adata.var_names.str.startswith(&quot;MT-&quot;) </span><br><span class="line"># 这一行代码是将adata中所有基因名称以&quot;MT-&quot;开头的基因标记为线粒体基因，存储到adata.var[&quot;mt&quot;]中。</span><br><span class="line"># ribosomal genes</span><br><span class="line">adata.var[&quot;ribo&quot;] = adata.var_names.str.startswith((&quot;RPS&quot;, &quot;RPL&quot;))</span><br><span class="line"># 这一行代码是将adata中所有基因名称以&quot;RPS&quot;或&quot;RPL&quot;开头的基因标记为核糖体基因，存储到adata.var[&quot;ribo&quot;]中。</span><br><span class="line"># hemoglobin genes.</span><br><span class="line">adata.var[&quot;hb&quot;] = adata.var_names.str.contains((&quot;^HB[^(P)]&quot;))</span><br><span class="line"># 这一行代码是将adata中所有基因名称符合正则表达式&quot;^HB[^(P)]&quot;的基因标记为血红蛋白基因，存储到adata.var[&quot;hb&quot;]中。其中&quot;^&quot;表示匹配字符串开头，&quot;[^(P)]&quot;表示除了字母&quot;P&quot;以外的任何字符。</span><br></pre></td></tr></table></figure>
<p>我们现在可以使用scanpy计算各自的QC指标。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sc.pp.calculate_qc_metrics(</span><br><span class="line">    adata, qc_vars=[&quot;mt&quot;, &quot;ribo&quot;, &quot;hb&quot;], inplace=True, percent_top=[20], log1p=True</span><br><span class="line">)</span><br><span class="line">adata</span><br><span class="line"># 这段代码是用于基因表达数据质量控制的。以下是其解释：</span><br><span class="line"># - &quot;sc&quot; 代表 &quot;scanpy&quot; 库。</span><br><span class="line"># - &quot;pp&quot; 是 &quot;preprocessing&quot; 的缩写，表示该函数用于预处理数据。</span><br><span class="line"># - &quot;calculate_qc_metrics&quot; 是一个函数，用于计算指定的质量控制指标。</span><br><span class="line"># - &quot;adata&quot; 是一个 Scanpy 对象，它存储了基因表达数据及其相关信息。</span><br><span class="line"># - &quot;qc_vars&quot; 是一个字符串列表，表示需要计算的质量控制指标，这里包括 &quot;mt&quot;、&quot;ribo&quot; 和 &quot;hb&quot;。</span><br><span class="line"># - &quot;inplace=True&quot; 表示直接修改 &quot;adata&quot; 对象，而不是返回一个新的对象。</span><br><span class="line"># - &quot;percent_top=[20]&quot; 表示对每个样本的前 20% 基因进行计算。</span><br><span class="line"># - &quot;log1p=True&quot; 表示在计算之前对数据进行对数转换，以便更好地处理数据分布。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AnnData object with n_obs × n_vars = 16934 × 36601</span><br><span class="line">    obs: &#x27;n_genes_by_counts&#x27;, &#x27;log1p_n_genes_by_counts&#x27;, &#x27;total_counts&#x27;, &#x27;log1p_total_counts&#x27;, &#x27;pct_counts_in_top_20_genes&#x27;, &#x27;total_counts_mt&#x27;, &#x27;log1p_total_counts_mt&#x27;, &#x27;pct_counts_mt&#x27;, &#x27;total_counts_ribo&#x27;, &#x27;log1p_total_counts_ribo&#x27;, &#x27;pct_counts_ribo&#x27;, &#x27;total_counts_hb&#x27;, &#x27;log1p_total_counts_hb&#x27;, &#x27;pct_counts_hb&#x27;</span><br><span class="line">    var: &#x27;gene_ids&#x27;, &#x27;feature_types&#x27;, &#x27;genome&#x27;, &#x27;mt&#x27;, &#x27;ribo&#x27;, &#x27;hb&#x27;, &#x27;n_cells_by_counts&#x27;, &#x27;mean_counts&#x27;, &#x27;log1p_mean_counts&#x27;, &#x27;pct_dropout_by_counts&#x27;, &#x27;total_counts&#x27;, &#x27;log1p_total_counts&#x27;</span><br></pre></td></tr></table></figure>
<p>正如我们所看到的，该函数向 .var 和 .obs 添加了一些附加列。我们想在这里强调其中的一些，更多有关不同指标的信息可以在 scanpy 文档中找到：</p>
<ul>
<li>.obs中的n_genes_by_counts是细胞中具有正计数的基因数，</li>
<li>total_counts是细胞计数的总数，这也可能被称为文库大小，以及</li>
<li>pct_counts_mt是细胞中线粒体总计数所占比例。</li>
</ul>
<p>现在，我们对每个样本绘制n_genes_by_counts、total_counts和pct_counts_mt三个QC协变量，以评估相应的细胞是否被捕获得很好。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p1 = sns.displot(adata.obs[&quot;total_counts&quot;], bins=100, kde=False)</span><br><span class="line"># 创建了一个直方图，并以adata数据集中的“total_counts”变量为x轴，bins=100表示将数据分为100个组，kde=False表示不显示核密度估计曲线。这个直方图可以用来了解数据集中基因表达的总数分布情况。</span><br><span class="line"># sc.pl.violin(adata, &#x27;total_counts&#x27;)</span><br><span class="line">p2 = sc.pl.violin(adata, &quot;pct_counts_mt&quot;)</span><br><span class="line"># 绘制了一个小提琴图，以adata数据集中的“pct_counts_mt”变量为x轴。小提琴图展示了该变量的分布情况，包括中位数、四分位数、异常值等，可以帮助了解数据集中的mt基因含量情况。</span><br><span class="line">p3 = sc.pl.scatter(adata, &quot;total_counts&quot;, &quot;n_genes_by_counts&quot;, color=&quot;pct_counts_mt&quot;)</span><br><span class="line"># 绘制了一个散点图。x轴为adata数据集中的“total_counts”变量，y轴为“n_genes_by_counts”变量，color=&quot;pct_counts_mt&quot;表示将点的颜色根据“pct_counts_mt”变量的值来确定。这个散点图可以用来了解基因表达总数和基因数目之间的关系，以及它们和mt基因含量之间的关系。</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/16356584/1681403037054-d6d1a44b-f79d-4699-a410-239ed22c27a9.png#averageHue=%23f9f9f9&clientId=u544cf9e1-ee1c-4&from=paste&height=337&id=ufcd9ef1e&name=image.png&originHeight=337&originWidth=363&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12074&status=done&style=none&taskId=ueced663a-7c49-40bf-ac7c-60b99491e65&title=&width=363" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/16356584/1681403045008-869f98a1-b247-4dfe-83e3-3039235c0403.png#averageHue=%23f3f3f3&clientId=u544cf9e1-ee1c-4&from=paste&height=303&id=u942061f1&name=image.png&originHeight=303&originWidth=327&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17037&status=done&style=none&taskId=u1aa126ad-10fd-43e8-936b-a250ea682e3&title=&width=327" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/16356584/1681403053704-04c0777e-1059-4e56-85af-0c26aba70a6b.png#averageHue=%23f5f5f5&clientId=u544cf9e1-ee1c-4&from=paste&height=323&id=uecc72b99&name=image.png&originHeight=323&originWidth=364&originalType=binary&ratio=1&rotation=0&showTitle=false&size=25520&status=done&style=none&taskId=u8d6e05a4-bd8d-49e2-90f0-3b08e990452&title=&width=364" alt="image.png"><br>图表显示，一些reads具有相对较高的线粒体计数百分比，这通常与细胞降解有关。但由于每个细胞的计数数量足够高，大多数细胞的线粒体reads百分比低于20％，因此我们仍然可以处理数据。基于这些图表，现在可以定义手动阈值来过滤细胞。相反，我们将展示使用MAD进行自动阈值和过滤的QC。<br>首先，我们定义一个函数，该函数接受一个度量标准，即.obs中的一列和筛选策略中仍然允许的MAD数（nmad）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def is_outlier(adata, metric: str, nmads: int):</span><br><span class="line">    M = adata.obs[metric]</span><br><span class="line">    outlier = (M &lt; np.median(M) - nmads * median_abs_deviation(M)) | (</span><br><span class="line">        np.median(M) + nmads * median_abs_deviation(M) &lt; M</span><br><span class="line">    )</span><br><span class="line">    return outlier</span><br><span class="line"># 这段代码定义了一个名为 &quot;is_outlier&quot; 的函数，它的作用是检测adata数据集中指标为metric的数据是否# 为异常值。其中，参数metric是一个字符串类型，表示要检测的指标名称；参数nmads是一个整数类型，表示# 要检测的指标是否为异常值的阈值。</span><br><span class="line"></span><br><span class="line"># 在函数中，首先从adata中的obs属性中获取指标为metric的数据，并赋值给变量M。然后，通过计算中位数# 绝对偏差(median_abs_deviation)和中位数(median)，得到数据中的异常值。最后，通过比较M与异常值的# 大小，得到一个布尔型的数组，其中True表示M中对应的数据为异常值，False表示M中对应的数据不是异常# 值。最终将这个布尔型数组作为函数的输出。</span><br><span class="line"></span><br><span class="line"># 具体而言，这段代码使用了numpy中的median和median_abs_deviation函数，这两个函数可以方便地计算中# 位数和中位数绝对偏差。其中，中位数绝对偏差可以作为一种比标准差更鲁棒的异常值检测方法，具有一定的# 优势。</span><br></pre></td></tr></table></figure>
<p>我们现在将该函数应用于<code>log1p_total_counts</code>、<code>log1p_n_genes_by_counts</code>和<code>pct_counts_in_top_20_genes</code> QC协变量，每个阈值为5个MADs。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">adata.obs[&quot;outlier&quot;] = (</span><br><span class="line">    is_outlier(adata, &quot;log1p_total_counts&quot;, 5)</span><br><span class="line">    | is_outlier(adata, &quot;log1p_n_genes_by_counts&quot;, 5)</span><br><span class="line">    | is_outlier(adata, &quot;pct_counts_in_top_20_genes&quot;, 5)</span><br><span class="line">)</span><br><span class="line">adata.obs.outlier.value_counts()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">False    16065</span><br><span class="line">True       869</span><br><span class="line">Name: outlier, dtype: int64</span><br></pre></td></tr></table></figure>
<p><code>pct_counts_Mt</code> 通过 3 个 MAD 进行了过滤。此外，具有线粒体计数百分比超过 8% 的细胞也被过滤掉了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adata.obs[&quot;mt_outlier&quot;] = is_outlier(adata, &quot;pct_counts_mt&quot;, 3) | (</span><br><span class="line">    adata.obs[&quot;pct_counts_mt&quot;] &gt; 8</span><br><span class="line">)</span><br><span class="line">adata.obs.mt_outlier.value_counts()</span><br><span class="line"># 这段代码的作用是将单细胞数据集中每个细胞的线粒体基因比例计算出来，并通过设定阈值8和3σ来判断哪些细胞是线粒体基因比例异常的细胞。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">False    15240</span><br><span class="line">True      1694</span><br><span class="line">Name: mt_outlier, dtype: int64</span><br></pre></td></tr></table></figure>
<p>现在，我们根据这两列附加的信息筛选我们的AnnData对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(f&quot;Total number of cells: &#123;adata.n_obs&#125;&quot;)</span><br><span class="line">adata = adata[(~adata.obs.outlier) &amp; (~adata.obs.mt_outlier)].copy()</span><br><span class="line"></span><br><span class="line">print(f&quot;Number of cells after filtering of low quality cells: &#123;adata.n_obs&#125;&quot;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码主要是对单细胞转录组数据进行了过滤处理。以下是对代码的解释：<br>首先，使用 “print(f”Total number of cells: {adata.n_obs}”)” 语句输出细胞总数，其中 f”…” 是 f-string，用于格式化输出字符串，将大括号内的变量替换为变量的值。<br>接下来，使用 “(<del>adata.obs.outlier) &amp; (</del>adata.obs.mt_outlier)” 进行细胞质量过滤，过滤掉质量不佳的细胞。这里的符号 “~” 表示取反，即将值为 True 的元素变为 False，将值为 False 的元素变为 True。”&amp;” 表示逻辑与，即两个条件都满足才为 True。<br>最后，使用 “print(f”Number of cells after filtering of low quality cells: {adata.n_obs}”)” 输出经过质量过滤后的细胞数。<br>总体来说，这段代码的作用是输出细胞总数和过滤掉低质量细胞后的细胞数。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1 = sc.pl.scatter(adata, &quot;total_counts&quot;, &quot;n_genes_by_counts&quot;, color=&quot;pct_counts_mt&quot;)</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/16356584/1681403913489-80c59486-16c6-4e9d-b8c7-23c6f11dadcc.png#averageHue=%23f7f7f7&clientId=u544cf9e1-ee1c-4&from=paste&height=335&id=u0e304a26&name=image.png&originHeight=335&originWidth=344&originalType=binary&ratio=1&rotation=0&showTitle=false&size=28583&status=done&style=none&taskId=ub55ea8eb-659b-4c42-ab8d-5f8bf21d659&title=&width=344" alt="image.png"></p>
<h2 id="6-4-环境RNA的校正"><a href="#6-4-环境RNA的校正" class="headerlink" title="6.4. 环境RNA的校正"></a>6.4. 环境RNA的校正</h2><p>针对基于液滴的单细胞RNA测序实验，由于在与细胞一起分配到液滴中的稀释液中存在一定量的背景mRNA，因此会产生背景污染。这种污染不代表液滴内所含细胞的表达情况，而代表的是溶液中含有的表达物质。<br>基于液滴的单细胞RNA测序可以对多个细胞中的基因进行唯一分子标识符（UMI）的计数，并旨在确定每个基因和每个细胞的分子数量。该方法假设每个液滴中仅含有来自单个细胞的mRNA。但是，双细胞、空液滴和无细胞RNA都可能违反这个假设。无细胞的mRNA分子代表在稀释液中存在的背景mRNA。这些分子会分布在液滴中并随之被测序。这种细胞外mRNA的污染通常被称为“汤”，这是由细胞溶解引起的。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/16356584/1681484754150-4a5a69ae-5fd3-410a-8f3b-62020310e401.png#averageHue=%23989a98&clientId=u544cf9e1-ee1c-4&from=paste&height=256&id=ua3bd2cd2&name=image.png&originHeight=256&originWidth=453&originalType=binary&ratio=1&rotation=0&showTitle=true&size=51999&status=done&style=none&taskId=u3c82a63d-33dd-4ee3-87d2-10ccb8687ea&title=%E5%9B%BE6.2%20%E5%9C%A8%E6%B6%B2%E6%BB%B4%E6%B5%8B%E5%BA%8F%E6%8A%80%E6%9C%AF%E4%B8%AD%EF%BC%8C%E6%B6%B2%E6%BB%B4%E5%8F%AF%E4%BB%A5%E5%8C%85%E5%90%AB%E7%8E%AF%E5%A2%83RNA%E6%88%96%E5%8F%8C%E4%BD%93%EF%BC%88%E6%8D%95%E8%8E%B7%E5%A4%9A%E4%B8%AA%E7%BB%86%E8%83%9E%E7%9A%84%E6%B6%B2%E6%BB%B4%EF%BC%89%E3%80%82%20%E6%9D%82%E8%B4%A8%E7%8E%AF%E5%A2%83RNA%E8%A2%AB%E6%9D%A1%E5%BD%A2%E7%A0%81%E5%8C%96%EF%BC%8C%E5%B9%B6%E4%B8%8E%E6%9D%A5%E8%87%AA%E7%BB%86%E8%83%9E%E7%9A%84%E6%9C%AC%E5%9C%B0mRNA%E4%B8%80%E8%B5%B7%E8%AE%A1%E6%95%B0%EF%BC%8C%E5%AF%BC%E8%87%B4%E8%AE%A1%E6%95%B0%E6%B7%B7%E6%B7%86%E3%80%82&width=453" alt="image.png" title="图6.2 在液滴测序技术中，液滴可以包含环境RNA或双体（捕获多个细胞的液滴）。 杂质环境RNA被条形码化，并与来自细胞的本地mRNA一起计数，导致计数混淆。"><br>细胞外游离mRNA分子，也称为环境RNA，可能会干扰观察到的计数，并被视为背景污染。对于基于液滴的单细胞RNA测序数据集进行细胞外mRNA校正非常重要，因为它可能会扭曲我们的下游分析数据的解释。一般而言，每种输入溶液的浓度都不同，并取决于数据集中各个细胞的表达模式。像SoupX [Young and Behjati，2020]和DecontX [Yang et al.，2020]这样的去除环境mRNA的方法旨在估计污染物的组成，并根据污染物的表达进行计数矩阵的校正。<br>作为第一步，SoupX计算污染物的组成。它从未过滤的Cellranger矩阵中的空滴中估计环境mRNA表达谱。接下来，SoupX估计每个细胞的特定污染分数。最后，根据环境mRNA表达谱和估计的污染物，对表达矩阵进行校正。<br>SoupX的输出是修改后的计数矩阵，可用于任何下游分析工具。<br>我们现在加载所需的Python和R软件包，以便运行SoupX。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import anndata2ri</span><br><span class="line">import logging</span><br><span class="line"></span><br><span class="line">import rpy2.rinterface_lib.callbacks as rcb</span><br><span class="line">import rpy2.robjects as ro</span><br><span class="line"></span><br><span class="line">rcb.logger.setLevel(logging.ERROR)</span><br><span class="line">ro.pandas2ri.activate()</span><br><span class="line">anndata2ri.activate()</span><br><span class="line"></span><br><span class="line">%load_ext rpy2.ipython</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码的作用是在Python中调用R语言的库，并且使用R语言的环境。具体解释如下：</p>
<ul>
<li>“import anndata2ri”：这行代码是导入名为anndata2ri的Python库。它的作用是将Python中的AnnData对象转换为R语言中的SingleCellExperiment对象。</li>
<li>“import logging”：这行代码是导入Python的日志记录模块，用于记录程序的运行情况。</li>
<li>“import rpy2.rinterface_lib.callbacks as rcb”：这行代码是导入名为rcb的Python库，用于与R语言的交互界面进行通信。</li>
<li>“import rpy2.robjects as ro”：这行代码是导入名为ro的Python库，用于与R语言的对象进行交互。</li>
<li>“rcb.logger.setLevel(logging.ERROR)”：这行代码是设置日志级别为ERROR，表示只记录错误信息。</li>
<li>“ro.pandas2ri.activate()”：这行代码是启用pandas2ri功能，表示可以在R和Python之间传递pandas数据结构。</li>
<li>“anndata2ri.activate()”：这行代码是启用anndata2ri功能，表示可以在R和Python之间传递AnnData数据结构。</li>
<li>“%load_ext rpy2.ipython”：这行代码是加载rpy2.ipython扩展，表示在Jupyter Notebook中可以直接使用R语言的代码。</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%%R</span><br><span class="line">library(SoupX)</span><br><span class="line"># 使用&quot;%%R&quot;语句将代码置于R代码块中，以便在Jupyter Notebook或其他类似环境中使用。</span><br></pre></td></tr></table></figure>
<p>SoupX可以在没有聚类信息的情况下运行，但是Young和Behjati [Young and Behjati，2020]指出，如果提供基本的聚类信息，则结果会更好。SoupX可以使用由cellranger产生的默认聚类或手动定义聚类。在本笔记本中，我们将展示后者，因为SoupX的结果对所使用的聚类不是非常敏感。</p>
<p>现在，我们创建AnnData对象的一个副本，对其进行归一化、降维处理并计算默认的Leiden聚类。后续章节将详细介绍聚类。现在，我们只需要知道，Leiden聚类为我们的数据集中的细胞提供了分区（社区）。我们将获得的聚类保存为soupx_groups，并删除AnnData对象的副本以在笔记本中节省一些内存。</p>
<p>首先，我们生成AnnData对象的副本，对其进行归一化和log1p转换。此时，我们使用简单的偏移对数归一化。有关不同归一化技术的更多信息可以在归一化章节中找到。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adata_pp = adata.copy()</span><br><span class="line">sc.pp.normalize_per_cell(adata_pp)</span><br><span class="line">sc.pp.log1p(adata_pp)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段 Python 代码用于对基因表达数据进行预处理。<br>首先，将 adata 数据集复制一份，保存到 adata_pp 中，以避免修改原始数据集。<br>然后，使用 sc.pp.normalize_per_cell(adata_pp) 对每个细胞的基因表达值进行归一化处理。这个函数将每个细胞内的基因表达值除以该细胞中的总基因表达值，并将结果乘以一个比例因子，使得每个细胞的基因表达值在相同的尺度上。这样的处理可以消除不同细胞之间的技术差异，使得数据更容易比较和解释。<br>最后，使用 sc.pp.log1p(adata_pp) 对数据集进行对数变换。这个函数将基因表达值转换为对数值，以缩小不同基因之间的差距，并减小离群值的影响。对数变换通常是对基因表达数据的常见预处理步骤之一，它可以提高后续的分析和挖掘的可靠性和稳定性。</p>
</blockquote>
<p>接下来，我们计算数据的主成分以获得较低维度的表示。然后，使用该表示生成数据的邻域图并在KNN图上运行Leiden聚类。我们将聚类添加为soupX_groups到.obs中，并将其保存为向量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sc.pp.pca(adata_pp)</span><br><span class="line">sc.pp.neighbors(adata_pp)</span><br><span class="line">sc.tl.leiden(adata_pp, key_added=&quot;soupx_groups&quot;)</span><br><span class="line"></span><br><span class="line"># Preprocess variables for SoupX</span><br><span class="line">soupx_groups = adata_pp.obs[&quot;soupx_groups&quot;]</span><br></pre></td></tr></table></figure>
<p>我们现在可以删除AnnData对象的副本，因为我们生成了一个可以在soupX中使用的聚类向量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del adata_pp</span><br></pre></td></tr></table></figure>
<p>接下来，我们保存过滤后的cellranger输出的细胞名称、基因名称和数据矩阵。SoupX需要一个基因 x barcode的矩阵，因此我们必须转置 <code>.X</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cells = adata.obs_names</span><br><span class="line">genes = adata.var_names</span><br><span class="line">data = adata.X.T</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码解释：这段代码主要是在对adata数据进行处理，其中：</p>
<ul>
<li>cells &#x3D; adata.obs_names 表示获取adata中的样本名，将其赋值给变量cells；</li>
<li>genes &#x3D; adata.var_names 表示获取adata中的基因名，将其赋值给变量genes；</li>
<li>data &#x3D; adata.X.T 表示获取adata中的数据矩阵，将其转置后赋值给变量data。</li>
</ul>
</blockquote>
<p>SoupX 还需要细胞基因矩阵中的原始基因，通常在 cellranger 输出中称为 <code>raw_feature_bc_matrix.h5</code>。我们与之前类似地使用 scanpy 加载它，并在对象上运行 <code>.var_names_make_unique()</code>，然后转置相应的 <code>.X</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">adata_raw = sc.read_10x_h5(</span><br><span class="line">    filename=&quot;raw_feature_bc_matrix.h5&quot;,</span><br><span class="line">    backup_url=&quot;https://figshare.com/ndownloader/files/39546217&quot;,</span><br><span class="line">)</span><br><span class="line">adata_raw.var_names_make_unique()</span><br><span class="line">data_tod = adata_raw.X.T</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Variable names are not unique. To make them unique, call `.var_names_make_unique`.</span><br><span class="line">Variable names are not unique. To make them unique, call `.var_names_make_unique`.</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del adata_raw</span><br></pre></td></tr></table></figure>
<p>我们现在已经准备好运行SoupX了。输入是形状为barcode x 细胞的经过过滤的cellranger矩阵、形状为barcode x droplets的来自cellranger的原始滴度表、基因和细胞名称以及通过简单Leiden聚类获得的聚类。输出将是已纠正的计数矩阵。</p>
<p>我们首先从滴度表和细胞表构造所谓的<code>SoupChannel</code>。接下来，我们向SoupChannel对象添加元数据，可以是任何<code>data.frame</code>的形式。我们在此添加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">%%R -i data -i data_tod -i genes -i cells -i soupx_groups -o out </span><br><span class="line"></span><br><span class="line"># specify row and column names of data</span><br><span class="line">rownames(data) = genes</span><br><span class="line">colnames(data) = cells</span><br><span class="line"># ensure correct sparse format for table of counts and table of droplets</span><br><span class="line">data &lt;- as(data, &quot;sparseMatrix&quot;)</span><br><span class="line">data_tod &lt;- as(data_tod, &quot;sparseMatrix&quot;)</span><br><span class="line"></span><br><span class="line"># Generate SoupChannel Object for SoupX </span><br><span class="line">sc = SoupChannel(data_tod, data, calcSoupProfile = FALSE)</span><br><span class="line"></span><br><span class="line"># Add extra meta data to the SoupChannel object</span><br><span class="line">soupProf = data.frame(row.names = rownames(data), est = rowSums(data)/sum(data), counts = rowSums(data))</span><br><span class="line">sc = setSoupProfile(sc, soupProf)</span><br><span class="line"># Set cluster information in SoupChannel</span><br><span class="line">sc = setClusters(sc, soupx_groups)</span><br><span class="line"></span><br><span class="line"># Estimate contamination fraction</span><br><span class="line">sc  = autoEstCont(sc, doPlot=FALSE)</span><br><span class="line"># Infer corrected table of counts and rount to integer</span><br><span class="line">out = adjustCounts(sc, roundToInt = TRUE)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码解释：这段代码使用了R语言，并且包含了一些命令行参数和函数调用。下面对其进行解释：</p>
<ul>
<li>“%%R -i data -i data_tod -i genes -i cells -i soupx_groups -o out” 是Jupyter Notebook的语法，指示R内核将其余部分的代码解释为R语言。此外，它还定义了五个输入变量（data、data_tod、genes、cells和soupx_groups）和一个输出变量（out）。</li>
<li>“rownames(data) &#x3D; genes”和”colnames(data) &#x3D; cells” 分别将输入变量data的行和列命名为genes和cells。</li>
<li>“data &lt;- as(data, ‘sparseMatrix’)”将数据表data转换为R语言中的稀疏矩阵格式。</li>
<li>“data_tod &lt;- as(data_tod, ‘sparseMatrix’)”将数据表data_tod转换为稀疏矩阵格式。</li>
<li>“sc &#x3D; SoupChannel(data_tod, data, calcSoupProfile &#x3D; FALSE)”创建一个名为sc的对象，其中包含了对于SoupX软件的输入数据，即样本的计数表和细胞的亚型分组信息。</li>
<li>“soupProf &#x3D; data.frame(row.names &#x3D; rownames(data), est &#x3D; rowSums(data)&#x2F;sum(data), counts &#x3D; rowSums(data))”创建了一个名为soupProf的数据框，其中包含了估计每个基因表达的平均值，即est列，以及每个基因的计数，即counts列。</li>
<li>“sc &#x3D; setSoupProfile(sc, soupProf)” 将数据框soupProf中的内容添加到sc对象中，以估计每个基因的表达值。</li>
<li>“sc &#x3D; setClusters(sc, soupx_groups)” 将亚型分组信息添加到sc对象中。</li>
<li>“sc  &#x3D; autoEstCont(sc, doPlot&#x3D;FALSE)” 通过调用autoEstCont函数，基于污染来源估计污染率。</li>
<li>“out &#x3D; adjustCounts(sc, roundToInt &#x3D; TRUE)”调整每个基因的计数值，使其满足估计的污染率，并将其转换为整数。最终结果存储在变量out中。</li>
</ul>
</blockquote>
<p>SoupX成功推断出修正后的计数，现在我们可以将其存储为layer。在所有后续的分析步骤中，我们希望使用SoupX修正后的计数矩阵，因此我们将<code>.X</code>用SoupX修正的矩阵覆盖。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adata.layers[&quot;counts&quot;] = adata.X</span><br><span class="line">adata.layers[&quot;soupX_counts&quot;] = out.T</span><br><span class="line">adata.X = adata.layers[&quot;soupX_counts&quot;]</span><br></pre></td></tr></table></figure>
<p>接下来，我们还会过滤掉在至少20个细胞中没有检测到的基因，因为它们没有信息价值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(f&quot;Total number of genes: &#123;adata.n_vars&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># Min 20 cells - filters out 0 count genes</span><br><span class="line">sc.pp.filter_genes(adata, min_cells=20)</span><br><span class="line">print(f&quot;Number of genes after cell filter: &#123;adata.n_vars&#125;&quot;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Total number of genes: 36601</span><br><span class="line">Number of genes after cell filter: 20171</span><br></pre></td></tr></table></figure>
<h2 id="6-5-双细胞检测"><a href="#6-5-双细胞检测" class="headerlink" title="6.5. 双细胞检测"></a>6.5. 双细胞检测</h2><p>双细胞是指以相同的细胞barcode进行测序的两个细胞，例如，如果它们被捕获在同一滴液滴中。因此，我们一直使用术语“barcode”而非“细胞”。如果同一细胞类型（但来自不同个体）形成了双细胞，则称其为同源型双细胞，否则称为异源型双细胞。同源型双细胞不一定可从计数矩阵中识别，并且通常被认为是无害的，因为它们可以通过细胞哈希或SNP进行识别。因此，它们的识别不是双细胞检测方法的主要目标。</p>
<p>由不同细胞类型或状态形成的双细胞称为异源型双细胞。它们的识别至关重要，因为它们很可能被错误分类，导致下游分析步骤出现扭曲。因此，双细胞检测和去除通常是初始预处理步骤。双细胞可以通过其高读数和检测特征进行识别，或者通过创建人工双细胞并将其与数据集中存在的细胞进行比较的方法进行识别。双细胞检测方法计算效率高，存在几个软件包可用于此任务。<br>[Xi and Li, 2021] 对比了九种不同的双细胞检测方法，并评估了它们在计算效率和双细胞检测准确性方面的表现。此外，他们还在补充测试中评估了 scDblFinder 的性能，结果显示 scDblFinder 实现了最高的双细胞检测准确性和较好的计算效率和稳定性 [Xi and Li, 2021]。</p>
<p>在本教程中，我们将展示 scDblFinder R 包。scDblFinder 随机选择两个液滴，并通过平均其基因表达谱创建人工双细胞。然后将双细胞得分定义为每个液滴在主成分空间的 k-最近邻图中的人工双细胞的分数。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/16356584/1681486404180-bf299c5e-3335-4dcd-9035-373c44bd7d3a.png#averageHue=%23f1f1f1&clientId=u544cf9e1-ee1c-4&from=paste&height=258&id=ue73c66c1&name=image.png&originHeight=258&originWidth=1012&originalType=binary&ratio=1&rotation=0&showTitle=true&size=104577&status=done&style=none&taskId=u1e5d4d62-4c6a-4080-8dbf-0694abd3568&title=%E5%9B%BE6.3%20%E5%8F%8C%E4%BD%93%E6%98%AF%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E7%BB%86%E8%83%9E%E7%9A%84%E6%B6%B2%E6%BB%B4%E3%80%82%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8F%8C%E4%BD%93%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95%E9%80%9A%E8%BF%87%E9%9A%8F%E6%9C%BA%E5%AD%90%E9%87%87%E6%A0%B7%E7%BB%86%E8%83%9E%E5%AF%B9%E5%B9%B6%E5%B9%B3%E5%9D%87%E5%AE%83%E4%BB%AC%E7%9A%84%E5%9F%BA%E5%9B%A0%E8%A1%A8%E8%BE%BE%E8%B0%B1%E6%9D%A5%E7%94%9F%E6%88%90%E4%BA%BA%E5%B7%A5%E5%8F%8C%E4%BD%93%EF%BC%8C%E4%BB%A5%E8%8E%B7%E5%BE%97%E5%8F%8C%E4%BD%93%E8%AE%A1%E6%95%B0%E3%80%82%E8%BF%99%E4%BA%9B%E4%BA%BA%E5%B7%A5%E5%8F%8C%E4%BD%93%E4%B8%8E%E5%85%B6%E4%BD%99%E5%91%BC%E5%8F%AB%E4%B8%80%E8%B5%B7%E6%8A%95%E5%BD%B1%E5%88%B0%E8%BE%83%E4%BD%8E%E7%BB%B4%E7%9A%84%E4%B8%BB%E6%88%90%E5%88%86%E7%A9%BA%E9%97%B4%E4%B8%AD%E3%80%82%E5%8F%8C%E4%BD%93%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95%E5%9F%BA%E4%BA%8Ek%E6%9C%80%E8%BF%91%E9%82%BB%E5%9B%BE%E4%B8%AD%E4%BA%BA%E5%B7%A5%E5%8F%8C%E4%BD%93%E9%82%BB%E5%B1%85%E7%9A%84%E6%95%B0%E9%87%8F%E8%AE%A1%E7%AE%97%E5%8F%8C%E4%BD%93%E5%BE%97%E5%88%86%E3%80%82&width=1012" alt="image.png" title="图6.3 双体是包含多个细胞的液滴。常见的双体检测方法通过随机子采样细胞对并平均它们的基因表达谱来生成人工双体，以获得双体计数。这些人工双体与其余呼叫一起投影到较低维的主成分空间中。双体检测方法基于k最近邻图中人工双体邻居的数量计算双体得分。"><br>我们首先加载一些额外的Python和R包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%%R</span><br><span class="line">library(Seurat)</span><br><span class="line">library(scater)</span><br><span class="line">library(scDblFinder)</span><br><span class="line">library(BiocParallel)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_mat = adata.X.T</span><br></pre></td></tr></table></figure>
<p>我们现在可以通过将 data_mat 作为 SingleCellExperiment 的输入来启动 scDblFinder 中的双子检测。scBblFinder 会在 sce 的 colData 中添加几列数据。其中三列可能对分析有用：</p>
<ul>
<li>sce$scDblFinder.score：最终的双子得分（得分越高，该细胞是双子的可能性越大）</li>
<li>sce$scDblFinder.ratio：细胞邻域中人工双子的比率</li>
<li>sce$scDblFinder.class：分类（双子或单子）</li>
</ul>
<p>我们将只输出 class 参数并将其存储在 .obs 中的 AnnData 对象中。其他参数可以类似地添加到 AnnData 对象中。<br>我们将仅输出类参数并将其存储在 .obs 中的 AnnData 对象中。其他参数也可以类似地添加到 AnnData 对象中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%%R -i data_mat -o doublet_score -o doublet_class</span><br><span class="line"></span><br><span class="line">set.seed(123) # 设置随机数种子，以保证每次运行得到的结果相同。</span><br><span class="line">sce = scDblFinder(</span><br><span class="line">    SingleCellExperiment(</span><br><span class="line">        list(counts=data_mat),</span><br><span class="line">    ) </span><br><span class="line">)</span><br><span class="line">doublet_score = sce$scDblFinder.score</span><br><span class="line">doublet_class = sce$scDblFinder.class</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码解释：<br>这段代码使用R语言进行单细胞测序数据的双倍体检测。以下是代码的解释：</p>
<ol>
<li>“%%R -i data_mat -o doublet_score -o doublet_class”：这是一个Jupyter Notebook（一种交互式编程环境）的命令，指示程序在R内核中执行，并将数据矩阵”data_mat”输入程序，并将结果”doublet_score”和”doublet_class”输出到Python内核中。 </li>
<li>“set.seed(123)”：设置随机数种子以确保在每次运行时获得相同的结果。 </li>
<li>“sce &#x3D; scDblFinder(SingleCellExperiment(list(counts&#x3D;data_mat)))”：创建一个单细胞实验对象”SingleCellExperiment”，其中包含基因表达计数数据”data_mat”。然后，使用”scDblFinder”函数进行双倍体检测，并将结果存储在变量”sce”中。 </li>
<li>“doublet_score &#x3D; sce$scDblFinder.score”：从”sce”对象中提取双倍体检测分数（”score”）并将结果存储在”doublet_score”变量中。 </li>
<li>“doublet_class &#x3D; sce$scDblFinder.class”：从”sce”对象中提取双倍体检测分类结果（”class”）并将结果存储在”doublet_class”变量中。</li>
</ol>
</blockquote>
<p>scDblFinder 输出一个分类为<code>Singlet</code>（1）和<code>Doublet</code>（2）的类。我们将其添加到我们的 AnnData 对象中的 <code>.obs</code> 中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adata.obs[&quot;scDblFinder_score&quot;] = doublet_score</span><br><span class="line">adata.obs[&quot;scDblFinder_class&quot;] = doublet_class</span><br><span class="line">adata.obs.scDblFinder_class.value_counts()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">singlet    11956</span><br><span class="line">doublet     2858</span><br><span class="line">Name: scDblFinder_class, dtype: int64</span><br></pre></td></tr></table></figure>
<p>我们建议现在将已确定的双体留在数据集中，在可视化过程中检查双体。</p>
<p>在下游聚类过程中，重新评估质量控制和所选参数可能有助于过滤更多或更少的细胞。我们现在可以保存数据集并继续进行规范化章节。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adata.write(&quot;s4d8_quality_control.h5ad&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="6-6-主要观点"><a href="#6-6-主要观点" class="headerlink" title="6.6. 主要观点"></a>6.6. 主要观点</h2><ol>
<li>质量不佳的细胞过滤应基于中位数绝对偏差，并采用宽松的截断值，以避免对较小的亚群体产生偏见。</li>
<li>基于特征的过滤对下游任务没有显示出好处。</li>
<li>可以使用scDblFinder等工具有效检测双倍体。</li>
<li>不应在表示多个批次的聚合scRNA-seq数据上运行双倍体检测方法。</li>
</ol>
<h2 id="6-7-References"><a href="#6-7-References" class="headerlink" title="6.7. References"></a>6.7. References</h2><p><a target="_blank" rel="noopener" href="https://www.sc-best-practices.org/preprocessing_visualization/quality_control.html#id5">qcGSR20</a><br>Pierre-Luc Germain, Anthony Sonrel, and Mark D. Robinson. pipeComp, a general framework for the evaluation of computational pipelines, reveals performant single cell rna-seq preprocessing tools. <em>Genome Biology</em>, 21(1):227, September 2020. URL: <a target="_blank" rel="noopener" href="https://doi.org/10.1186/s13059-020-02136-7">https://doi.org/10.1186/s13059-020-02136-7</a>, <a target="_blank" rel="noopener" href="https://doi.org/10.1186/s13059-020-02136-7">doi:10.1186&#x2F;s13059-020-02136-7</a>.<br><a target="_blank" rel="noopener" href="https://www.sc-best-practices.org/preprocessing_visualization/quality_control.html#id3">qcLBC+21</a><br>Malte D Luecken, Daniel Bernard Burkhardt, Robrecht Cannoodt, Christopher Lance, Aditi Agrawal, Hananeh Aliee, Ann T Chen, Louise Deconinck, Angela M Detweiler, Alejandro A Granados, Shelly Huynh, Laura Isacco, Yang Joon Kim, Dominik Klein, BONY DE KUMAR, Sunil Kuppasani, Heiko Lickert, Aaron McGeever, Honey Mekonen, Joaquin Caceres Melgarejo, Maurizio Morri, Michaela Müller, Norma Neff, Sheryl Paul, Bastian Rieck, Kaylie Schneider, Scott Steelman, Michael Sterr, Daniel J. Treacy, Alexander Tong, Alexandra-Chloe Villani, Guilin Wang, Jia Yan, Ce Zhang, Angela Oliveira Pisco, Smita Krishnaswamy, Fabian J Theis, and Jonathan M. Bloom. A sandbox for prediction and integration of dna, rna, and proteins in single cells. In <em>Thirty-fifth Conference on Neural Information Processing Systems Datasets and Benchmarks Track (Round 2)</em>. 2021. URL: <a target="_blank" rel="noopener" href="https://openreview.net/forum?id=gN35BGa1Rt">https://openreview.net/forum?id=gN35BGa1Rt</a>.<br><a target="_blank" rel="noopener" href="https://www.sc-best-practices.org/preprocessing_visualization/quality_control.html#id9">qcXL21a</a><br>Nan Miles Xi and Jingyi Jessica Li. Benchmarking Computational Doublet-Detection Methods for Single-Cell term<code>RNA</code> Sequencing Data. <em>Cell Systems</em>, 12(2):176–194.e6, 2021. URL: <a target="_blank" rel="noopener" href="https://www.sciencedirect.com/science/article/pii/S2405471220304592">https://www.sciencedirect.com/science/article/pii/S2405471220304592</a>, <a target="_blank" rel="noopener" href="https://doi.org/https://doi.org/10.1016/j.cels.2020.11.008">doi:https://doi.org/10.1016/j.cels.2020.11.008</a>.<br><a target="_blank" rel="noopener" href="https://www.sc-best-practices.org/preprocessing_visualization/quality_control.html#id10">qcXL21b</a><br>Nan Miles Xi and Jingyi Jessica Li. Protocol for executing and benchmarking eight computational doublet-detection methods in single-cell RNA sequencing data analysis. <em>STAR Protocols</em>, 2(3):100699, sep 2021. URL: <a target="_blank" rel="noopener" href="https://doi.org/10.1016%2Fj.xpro.2021.100699">https://doi.org/10.1016%2Fj.xpro.2021.100699</a>, <a target="_blank" rel="noopener" href="https://doi.org/10.1016/j.xpro.2021.100699">doi:10.1016&#x2F;j.xpro.2021.100699</a>.<br><a target="_blank" rel="noopener" href="https://www.sc-best-practices.org/preprocessing_visualization/quality_control.html#id7">qcYCK+20</a><br>Shiyi Yang, Sean E. Corbett, Yusuke Koga, Zhe Wang, W Evan Johnson, Masanao Yajima, and Joshua D. Campbell. Decontamination of ambient rna in single-cell rna-seq with DecontX. <em>Genome Biology</em>, 21(1):57, March 2020. URL: <a target="_blank" rel="noopener" href="https://doi.org/10.1186/s13059-020-1950-6">https://doi.org/10.1186/s13059-020-1950-6</a>, <a target="_blank" rel="noopener" href="https://doi.org/10.1186/s13059-020-1950-6">doi:10.1186&#x2F;s13059-020-1950-6</a>.<br><strong>qcYB20(</strong><a target="_blank" rel="noopener" href="https://www.sc-best-practices.org/preprocessing_visualization/quality_control.html#id6">1</a><strong>,</strong><a target="_blank" rel="noopener" href="https://www.sc-best-practices.org/preprocessing_visualization/quality_control.html#id8">2</a><strong>)</strong><br>Matthew D Young and Sam Behjati. SoupX removes ambient term<code>RNA</code> contamination from droplet-based single-cell term<code>RNA</code> sequencing data. <em>GigaScience</em>, December 2020. URL: <a target="_blank" rel="noopener" href="https://doi.org/10.1093/gigascience/giaa151">https://doi.org/10.1093/gigascience/giaa151</a>, <a target="_blank" rel="noopener" href="https://doi.org/10.1093/gigascience/giaa151">doi:10.1093&#x2F;gigascience&#x2F;giaa151</a>.<br><a target="_blank" rel="noopener" href="https://www.sc-best-practices.org/preprocessing_visualization/quality_control.html#id2">qcZT21</a><br>Luke Zappia and Fabian J. Theis. Over 1000 tools reveal trends in the single-cell rna-seq analysis landscape. <em>Genome Biology</em>, 22(1):301, Oct 2021. URL: <a target="_blank" rel="noopener" href="https://doi.org/10.1186/s13059-021-02519-4">https://doi.org/10.1186/s13059-021-02519-4</a>, <a target="_blank" rel="noopener" href="https://doi.org/10.1186/s13059-021-02519-4">doi:10.1186&#x2F;s13059-021-02519-4</a>.</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2023/04/14/6.%20Quality%20Control/">http://example.com/2023/04/14/6.%20Quality%20Control/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2023/04/20/7.Normalization/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info"></div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B4%A8%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">质量控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E7%B4%A2%E5%BC%95"><span class="toc-number">1.1.</span> <span class="toc-text">6.1 索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE%E5%92%8C%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.</span> <span class="toc-text">6.2 环境设置和数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E8%BF%87%E6%BB%A4%E4%BD%8E%E8%B4%A8%E9%87%8F%E7%9A%84reads"><span class="toc-number">1.3.</span> <span class="toc-text">6.3. 过滤低质量的reads</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E7%8E%AF%E5%A2%83RNA%E7%9A%84%E6%A0%A1%E6%AD%A3"><span class="toc-number">1.4.</span> <span class="toc-text">6.4. 环境RNA的校正</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-%E5%8F%8C%E7%BB%86%E8%83%9E%E6%A3%80%E6%B5%8B"><span class="toc-number">1.5.</span> <span class="toc-text">6.5. 双细胞检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-%E4%B8%BB%E8%A6%81%E8%A7%82%E7%82%B9"><span class="toc-number">1.6.</span> <span class="toc-text">6.6. 主要观点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-References"><span class="toc-number">1.7.</span> <span class="toc-text">6.7. References</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/28/hello-world/" title="Hello World">Hello World</a><time datetime="2023-04-28T01:04:07.174Z" title="Created 2023-04-28 09:04:07">2023-04-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/22/9_Dimensionality%20Reduction/" title="No title">No title</a><time datetime="2023-04-22T13:01:20.122Z" title="Created 2023-04-22 21:01:20">2023-04-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/21/8.%20Feature%20selection/" title="No title">No title</a><time datetime="2023-04-21T14:35:06.487Z" title="Created 2023-04-21 22:35:06">2023-04-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/20/7.Normalization/" title="No title">No title</a><time datetime="2023-04-20T14:28:51.386Z" title="Created 2023-04-20 22:28:51">2023-04-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/14/6.%20Quality%20Control/" title="No title">No title</a><time datetime="2023-04-14T15:43:20.453Z" title="Created 2023-04-14 23:43:20">2023-04-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By John Doe</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>